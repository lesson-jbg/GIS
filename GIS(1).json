{
  "name": "GIS",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "recevie-image",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -400,
        0
      ],
      "id": "c5181a02-861a-487e-a59e-30a9cc123960",
      "name": "Webhook",
      "webhookId": "093660a8-ced7-4d88-a319-8d1e6a9adbf8"
    },
    {
      "parameters": {
        "jsCode": "// Get the model's full response\nconst rawSQL = $json.choices?.[0]?.message?.content || \"\";\n\n// Clean markdown fences (like ```sql ... ```)\nconst cleanedSQL = rawSQL.replace(/```sql|```/g, \"\").trim();\n\n// Split the content into steps\nconst steps = cleanedSQL\n  .split(/-- Step\\s*\\d+:/i)\n  .filter(s => s.trim() !== \"\")\n  .map((step, index) => {\n    const lines = step.trim().split(\"\\n\");\n    return {\n      step: index + 1,\n      description: lines[0].replace(/^--\\s*/, \"\").trim() || `Step ${index + 1}`,\n      sql: lines.slice(1).join(\"\\n\").trim()\n    };\n  });\n\n// Return both the cleaned SQL text and the structured steps\nreturn [\n  {\n    json: {\n      raw_sql: cleanedSQL,\n      steps\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        0
      ],
      "id": "3bae467f-5294-40f6-a8d2-88587e693709",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"myField\": {{ $json.toJsonString() }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        320,
        0
      ],
      "id": "1e4f941f-a3b2-4392-82fc-c31ce923546e",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 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"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Accept",
              "value": "application/json"
            },
            {
              "name": "X-Title",
              "value": "n8n GIS Image-to-SQL"
            },
            {
              "name": "HTTP-Referer",
              "value": "http://localhost:5678"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"gpt-4o-mini\",\n  \"temperature\": 0,\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"# System Prompt: GIS Workflow → SQL & Views (Image-to-SQL)\\nYou are a GIS engineer. You will receive:\\n* An image of a GIS workflow diagram (nodes like Buffer, Intersect, Clip, Dissolve, Union, Erase, Select by Location, Spatial Join, Reproject, Filter).\\n* Optional metadata about the database and schema.\\n\\nYour job:\\n1. Parse the diagram from the image.\\n2. Reconstruct the workflow as an ordered DAG of steps.\\n3. Translate each step into executable SQL (PostGIS preferred).\\n4. Produce views/materialized views that implement the workflow end-to-end.\\n5. Output a final query that returns the “best location” result set.\\n6. Document assumptions and parameters you inferred from the image.\\n\\n## Inputs (variables I will pass)\\n* DB_DIALECT: postgis (default) | spatialite | bigquery-gis | redshift-gis | duckdb-spatial\\n* DB_SCHEMA: e.g., public\\n* SRID: e.g., 4326\\n* GEOM_COL: default geom\\n* PRIMARY_TABLES: list of available base tables with columns (e.g., roads(geom, class), parcels(geom, landuse), water(geom, type), schools(geom, name), …)\\n* UNITS: meters (default) | feet\\n* MATERIALIZE: true creates materialized views; otherwise normal views\\n\\nIf something is missing, infer it from the image and state it under “Assumptions”.\\n\\n## Parsing the Image\\nDetect all nodes/tools: Buffer, Intersect, Clip, Union, Dissolve, Erase (Difference), Spatial Join, Select by Location, Filter/Attribute Query, Reproject, Merge, Calculate Area/Distance, Sort/Rank, Normalize/Reclassify, Weighted Overlay.\\nDetect all layers referenced (e.g., Roads, Parcels, Water bodies, Schools, Protected Areas, City Boundary).\\nExtract parameters (e.g., “Buffer Roads 500m”, “Clip to CityBoundary”, “Intersect with Water=‘river’”, “Distance < 1km from schools”, weights for overlay).\\nDetermine the flow order and dependencies.\\n\\n## Output Format (strict)\\nReturn the following sections in order:\\n1) Workflow JSON (inferred from the image)\\n2) Schema Assumptions\\n3) Reusable SQL Snippets (PostGIS)\\n4) DDL: Views / Materialized Views\\n5) Final “Best Location” Query\\n6) Indexing & Performance\\n7) Validation Checks\\n8) Assumptions & Parameters\\n\\nProvide runnable SQL blocks only, no extra prose.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"Analyze this GIS workflow and generate the SQL commands needed to implement it in QGIS.\\nInstructions:\\n- Use PostGIS syntax.\\n- Include table creation, spatial joins, and relevant queries.\\n- Output only the SQL commands.\"\n        },\n        {\n          \"type\": \"image_url\",\n          \"image_url\": {\n            \"url\": \"data:image/png;base64,{{$json.base64}}\"\n          }\n        }\n      ]\n    }\n  ]\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -80,
        0
      ],
      "id": "80f45543-9506-4114-a515-dde3739a8301",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "jsCode": "// Access binary data safely\nconst binary = $input.item.binary || $binary;\n\nif (!binary || !binary.data0 || !binary.data0.data) {\n  throw new Error(\"No binary data found under 'data0'. Check your Webhook or previous node output.\");\n}\n\n// Convert the buffer to a clean base64 string\nconst base64Data =\n  typeof binary.data0.data === 'string'\n    ? binary.data0.data\n    : Buffer.from(binary.data0.data).toString('base64');\n\n// Return a new item with the base64 string in JSON for easy access\nreturn [\n  {\n    json: {\n      base64: base64Data,\n      mimeType: binary.data0.mimeType,\n      fileName: binary.data0.fileName,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -256,
        0
      ],
      "id": "c5642a92-4514-475d-92bd-5702a48a1606",
      "name": "Code in JavaScript1"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "02abda83-f65e-494f-b32a-98d70761b480",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "5173e1022dc4cb08437ce2956c4b9066905adb482aa885c7b337adc9390c95f9"
  },
  "id": "8wigdHdhNmB2k3ip",
  "tags": []
}